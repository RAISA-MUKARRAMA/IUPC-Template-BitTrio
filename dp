DP:

1D:
vector<int> dp(n,-1);
  dp[0]=0;
  for(int ind=1;ind<n;ind++){
      int jumpTwo = INT_MAX;
        int jumpOne= dp[ind-1] + abs(height[ind]-height[ind-1]);
        if(ind>1)
            jumpTwo = dp[ind-2] + abs(height[ind]-height[ind-2]);
    
        dp[ind]=min(jumpOne, jumpTwo);
  }


2D:

int minPathSum(vector<vector<int>>& grid) {
        int m=grid.size();
        int n=grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        dp[0][0]=grid[0][0];

        // first row
        for(int j = 1; j < n; j++)
            dp[0][j] = grid[0][j] + dp[0][j-1];

        // first column
        for(int i = 1; i < m; i++)
            dp[i][0] = grid[i][0] + dp[i-1][0];
            
        for(int i=0;i<m;i++){
            for(int j=1;j<n;j++){
                if(i>0 && j>0)
                {
                    dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]);

                }
            }
        }
        return dp[m-1][n-1];
    }





int ninjaTraining(int n, vector<vector<int>>& points) 
{
  vector<vector<int>> dp(n, vector<int>(4, 0));
// dp[i][j] represents the maximum points at day i, considering the last activity as j
  dp[0][0] = max(points[0][1], points[0][2]);
  dp[0][1] = max(points[0][0], points[0][2]);
  dp[0][2] = max(points[0][0], points[0][1]);
  dp[0][3] = max(points[0][0], max(points[0][1], points[0][2]));

  for (int day = 1; day < n; day++) {
    for (int last = 0; last < 4; last++) {
      dp[day][last] = 0;
      // Iterate through the tasks for the current day
      for (int task = 0; task <= 2; task++) {
        if (task != last) {
          int activity = points[day][task] + dp[day - 1][task];
          dp[day][last] = max(dp[day][last], activity);
        }
      }
    }
  }

  // The maximum points for the last day with any activity can be found in dp[n-1][3]
  return dp[n - 1][3];
}
