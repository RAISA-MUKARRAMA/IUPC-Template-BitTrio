    int Rotated_search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;

        while (left <= right) {
            int mid = (left + right) / 2;

            if (nums[mid] == target) return mid;

            // Handle duplicates
            if (nums[left] == nums[mid] && nums[mid] == nums[right]) {
                left++;
                right--;
                continue;
            }

            // Left side is sorted
            if (nums[left] <= nums[mid]) {
                if (nums[left] <= target && target <= nums[mid]) {
                    right = mid - 1;
                }
                else {
                    left = mid + 1;
                }
            }
            // Right side is sorted
            else {
                if (nums[mid] <= target && target <= nums[right]) {
                    left = mid + 1;
                }
                else {
                    right = mid - 1;
                }
            }
        }

        return -1;
    }

jodi bole koto position kore sorted then 
if (arr[low] < ans) {
                index = low;
                ans = arr[low];
            }

            // Eliminate left half:
            low = mid + 1;
        }

lowest ta ber kore delete.




The lower bound algorithm finds the first or the smallest index in a sorted array where the value at that index is greater than or equal to a given key. directly gives ceil.
int lowerBound(vector<int> arr, int n, int x) {
    int low = 0, high = n - 1;
    int ans = n;

    while (low <= high) {
        int mid = (low + high) / 2;
        // maybe an answer
        if (arr[mid] >= x) {
            ans = mid;
            //look for smaller index on the left equal o hote pare
            high = mid - 1;
        }
        else {
            low = mid + 1; // look on the right
        }
    }
    return ans;
}




//to get floor it will be index-1 for upper bound
int upperBound(vector<int> &arr, int x, int n) {
    int low = 0, high = n - 1;
    int ans = n;

    while (low <= high) {
        int mid = (low + high) / 2;
        // maybe an answer
        if (arr[mid] > x) {
            ans = mid;
            //look for smaller index on the left equal hobe na
            high = mid - 1;
        }
        else {
            low = mid + 1; // look on the right
        }
    }
    return ans;
}





#include<bits/stdc++.h>
bool canWePlace (vector<int> &stalls, int dist, int cows){
int cntCows = 1, last=stalls[0];
for (int i = 1; i<stalls.size();i++) {
    if(stalls[i] - last >= dist)  {
    cntCows++;
    last stalls[i];
    }
if(cntCows >= cows) return true;
}
return false;
}
int aggressiveCows (vector<int> &stalls, int k)
{
    sort(stalls.begin(), stalls.end());
    int n=stalls.size();
    int low=1, high=stalls[n-1] - stalls[0];
    
    while(low <= high) {
        int mid = (low + high) / / 2;
        if(canWePlace (stalls, mid, k) == true) {
            low = mid+ 1;
        }
        else {
                high=mid-1;
        }
        
    }
        return high;
    }
